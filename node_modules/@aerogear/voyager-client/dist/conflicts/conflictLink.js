"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var apollo_link_error_1 = require("apollo-link-error");
exports.conflictLink = function (config) {
    /**
    * Fetch conflict data from the errors returned from the server
    * @param graphQLErrors array of errors to retrieve conflicted data from
    */
    var getConflictData = function (graphQLErrors) {
        if (graphQLErrors) {
            for (var _i = 0, graphQLErrors_1 = graphQLErrors; _i < graphQLErrors_1.length; _i++) {
                var err = graphQLErrors_1[_i];
                if (err.extensions) {
                    if (err.extensions.exception.conflictInfo) {
                        return err.extensions.exception.conflictInfo;
                    }
                }
            }
        }
    };
    return apollo_link_error_1.onError(function (_a) {
        var response = _a.response, operation = _a.operation, forward = _a.forward, graphQLErrors = _a.graphQLErrors;
        var data = getConflictData(graphQLErrors);
        if (data && config.conflictStrategy && config.conflictStateProvider) {
            var resolvedConflict = void 0;
            if (data.resolvedOnServer) {
                resolvedConflict = data.serverState;
                if (response) {
                    // Set data to resolved state
                    response.data = resolvedConflict;
                    // 🍴 eat error
                    response.errors = undefined;
                }
                if (config.conflictListener) {
                    config.conflictListener.conflictOccurred(operation.operationName, resolvedConflict, data.serverState, data.clientState);
                }
            }
            else {
                // resolve on client
                // ConflictResolutionStrategies interface is used
                if (config.conflictStrategy.strategies &&
                    !!config.conflictStrategy.strategies[operation.operationName]) {
                    var individualStrategy = config.conflictStrategy.strategies[operation.operationName];
                    resolvedConflict = individualStrategy(data.serverState, data.clientState);
                }
                else if (config.conflictStrategy.default) {
                    resolvedConflict = config.conflictStrategy.default(data.serverState, data.clientState);
                }
                if (config.conflictListener) {
                    config.conflictListener.conflictOccurred(operation.operationName, resolvedConflict, data.serverState, data.clientState);
                }
                operation.variables = config.conflictStateProvider.nextState(resolvedConflict);
                if (response) {
                    // 🍴 eat error
                    response.errors = undefined;
                }
                return forward(operation);
            }
        }
    });
};
//# sourceMappingURL=conflictLink.js.map